# C4編譯器
程式碼來源自陳鍾誠老師註解過後的的[c4.c](https://github.com/ccc-c/c4/blob/master/ccc/c4.c)，參考ChatGPT與老師的[C4原始碼解析](https://github.com/ccc111b/cpu2os/blob/master/%E6%9B%B8/%E7%B7%A8%E8%AD%AF%E5%99%A8/P1d-C4%E5%8E%9F%E5%A7%8B%E7%A2%BC%E8%A7%A3%E6%9E%90.md)的解釋後，並添加了一些個人註解。

* 其他參考:
  * [C in four function (c4) Compiler](https://hackmd.io/@srhuang/Bkk2eY5ES)
  * [gcc編譯器基本使用](https://blog.gtwang.org/programming/gcc-comipler-basic-tutorial-examples/)
___
# 編譯器介紹
C4 是 Robert Swierczek 寫的一個小型 C 語言編譯器，全部 527 行的原始碼。

C4 Compiler 不僅是個 C self-host compiler，它也啟發了許多人去撰寫自己的 Compiler，甚至是個很好的入門來了解 Compiler 。

C4 編譯完成後，會產生一種《堆疊機機器碼》放在記憶體內，然後 虛擬機 會立刻執行該機器碼。其最特別的功能在於他能自我編譯。
## 分類
按照生成代碼所運行的系統平台劃分，這個平台稱為目標平台。
* 本地編譯器：運行於與編譯器所在相同類型的計算機和操作系統之上。
* 交叉編譯器：輸出可以執行於不同的平台之上的編譯器。由於嵌入式系統通常沒有軟體開發環境，因此，為這類系統開發軟體時，通常需要使用交叉編譯器。

## 主要流程
原始碼（source code）→ 預處理器（preprocessor）→ 編譯器（compiler）→ 組譯程式（assembler）→ 目的碼（object code）→ 連結器（linker）→ 執行檔（executables），最後打包好的檔案就可以給電腦去判讀執行了。
___
# C4.c
* 函式說明
```
main(int argc, char **argv)      
```
主程式，主要是編譯器的初始化過程，它分配並初始化了程式執行所需的記憶體空間，並讀取輸入的程式碼。然後，它進行編譯和執行過程，最終返回程式的執行結果。
```
prog()                           
```
編譯整個程式，函式內部使用一個迴圈來處理程式中的不同部分，主要用於解析和編譯整個程式，包括全局變數和函式的定義、列舉的處理等。

初始化一些變數，包括bt（basetype）和i（計數器），並設置line為1（表示從第1行開始編譯）。

呼叫next()函式讀取下一個標記（token）。

進入一個迴圈，直到遇到結束標記（tk為0）為止。

根據目前的標記（token）進行不同的處理：

若標記為Int，則將bt設為INT並呼叫next()讀取下一個標記。

若標記為Char，則將bt設為CHAR並呼叫next()讀取下一個標記。

若標記為Enum，則表示遇到列舉定義。根據情況，可能需要跳過標識符或解析列舉的值。

其他情況下，表示遇到全局變數或函式定義。根據不同情況進行處理，包括解析參數、局部變數和函式體的定義。

繼續下一個標記的處理，直到遇到分號或右花括號為止。

返回編譯結果，0表示編譯成功。
```
stmt()                           
```
陳述式編譯，主要用於解析和處理不同類型的陳述式，並生成相應的指令以便後續執行。

若tk為If，代表是一個if語句，會進行相應的處理，包括檢查括號、解析表達式、設置條件分支指令等，然後遞迴處理後續的陳述式，若有else語句則也處理else的部分。

若tk為While，代表是一個while語句，會進行相應的處理，包括檢查括號、解析表達式、設置循環分支指令等，然後遞迴處理循環內的陳述式。

若tk為Return，代表是一個return語句，會進行相應的處理，包括解析表達式、設置返回指令等。

若tk為{，代表是一個區塊（block），即大括號內的多個陳述式，會遞迴處理區塊內的所有陳述式。

若tk為;，代表是一個空陳述，即不執行任何操作，直接跳過。

若以上條件均不滿足，則當作指定（assign）處理，即解析表達式並進行賦值操作。
```
expr(int lev)
```
運算式編譯，根據運算子的優先等級來解析運算式。該解析器支援數值、字串、sizeof、函數呼叫、變數、運算子和括號等不同的表達式。
```
next()
```
詞彙分析器（lexer），用於將程式碼分解為一系列的詞彙（tokens）。該函式 next() 會依序讀取 p 指針指向的字元，並將其轉換為對應的詞彙。

讀到換行符時，它會先輸出之前的那一行代碼，再輸出之前那一行所生成的目的碼（如果有的話），並且把行數增加 1。如果讀到井號字符（#），它會略過該行中的所有內容，直到讀到換行符。如果讀到字母或下劃線字符，它會把它視為變數名稱的開始，然後依次讀取更多的字符直到遇到不屬於變數名稱的字符為止。如果讀到數字字符，它會把它視為數字串的開始，然後依次讀取更多的數字字符直到遇到不屬於數字的字符為止。如果讀到斜線字符（/），它會判斷其後面是注釋還是除法運算符。如果讀到單引號或雙引號字符，它會把它視為字元或字符串的開始，然後依次讀取更多的字符直到讀到相同的引號字符為止。最後，如果讀到其他字符，它會判斷它是運算符還是標點符號。在每種情況下，它都會將所讀取的字符轉換成一個詞彙代碼（token code），然後將其存儲在全局變數 tk 中並返回。
```
run(int *pc, int *bp, int *sp)
```
簡單的虛擬機器，用於執行特定指令集的程式碼。通過解釋和執行指令，該虛擬機器能夠模擬不同的操作，包括數學計算、邏輯運算、記憶體存取和系統呼叫等。

以下是虛擬機所支援的指令集：
- `LEA`：載入區域變數的位址到累積器。
- `IMM`：載入全域變數的位址或立即值到累積器。
- `JMP`：無條件跳轉到指定位址。
- `JSR`：跳轉到副程式的指定位址，同時將返回位址壓入堆疊。
- `BZ`：若累積器為零，則跳轉到指定位址。
- `BNZ`：若累積器不為零，則跳轉到指定位址。
- `ENT`：進入副程式，將當前的堆疊暫存器指標 `sp` 儲存到框架暫存器 `bp` 中，並且分配一個新的堆疊區域。
- `ADJ`：調整堆疊大小，用於參數清理。
- `LEV`：離開副程式，復原堆疊框架並跳轉到返回位址。
- `LI`：從指定位址載入整數。
- `LC`：從指定位址載入字元。
- `SI`：將累積器的整數值儲存到指定位址。
- `SC`：將累積器的字元值儲存到指定位址。
- `PSH`：將累積器的值推入堆疊。
* 邏輯和算術運算指令：
- `OR`：按位或運算。
- `XOR`：按位互斥或運算。
- `AND`：按位與運算。
- `EQ`：相等比較。
- `NE`：不等比較。
- `LT`：小於比較。
- `GT`：大於比較。
- `LE`：小於等於比較。
- `GE`：大於等於比較。
- `SHL`：左移運算。
- `SHR`：右移運算。
- `ADD`：加法運算。
- `SUB`：減法運算。
- `MUL`：乘法運算。
- `DIV`：除法運算。
- `MOD`：取模運算。
- 系統呼叫指令：`OPEN`、`READ`、`CLOS`、`PRTF`、`MALC`、`FREE`、`MSET`、`MCMP`、`EXIT`。這些指令用於執行系統呼叫，例如開檔、讀檔、關檔、輸出格式化字串、動態記憶體分配、釋放記憶體、設定記憶體、比較記憶體和結束執行。
